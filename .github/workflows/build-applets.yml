---
name: Build and Update Applets

on:
  schedule:
    - cron: '0 0 * * 0' # Weekly on Sunday
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/build-applets.yml'

permissions:
  contents: write

jobs:
  build:
    name: Check for Applet Updates and Build
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends git jq ca-certificates

      - name: Define Applets
        id: applets
        run: |
          APPLET_JSON=$(jq -n '[
            {name: "cosmic-ext-applet-emoji-selector", url: "https://github.com/leb-kuchen/cosmic-ext-applet-emoji-selector"},
            {name: "cosmic-ext-applet-privacy-indicator", url: "https://github.com/D-Brox/cosmic-ext-applet-privacy-indicator"},
            {name: "cosmic-ext-applet-vitals", url: "https://github.com/Coinio/cosmic-ext-applet-vitals.git"},
            {name: "cosmic-applet-music-player", url: "https://github.com/Ebbo/cosmic-applet-music-player.git"},
            {name: "cosmic-ext-applet-caffeine", url: "https://github.com/tropicbliss/cosmic-ext-applet-caffeine"},
            {name: "cosmic-connect-applet", url: "https://github.com/cosmic-utils/cosmic-connect-applet.git"}
          ]')
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$APPLET_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build Applets
        id: build_applets
        run: |
          set -eoux pipefail
          CHANGES_MADE=false
          APPLET_LIST='${{ steps.applets.outputs.matrix }}'

          mkdir -p /tmp/artifacts

          for row in $(echo "${APPLET_LIST}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${row} | base64 --decode | jq -r ${1}
            }
            APPLET_NAME=$(_jq '.name')
            APPLET_URL=$(_jq '.url')

            echo "::group:: Checking ${APPLET_NAME}"
            LATEST_COMMIT=$(git ls-remote "${APPLET_URL}" HEAD | awk '{print $1}')
            CURRENT_COMMIT=$(jq -r ".[\"${APPLET_NAME}\"] // \"\"" build/applet-versions.json)

            if [ "${LATEST_COMMIT}" == "${CURRENT_COMMIT}" ]; then
              echo "${APPLET_NAME} is up to date. Skipping build."
              echo "::endgroup::"
              continue
            fi

             echo "New version detected for ${APPLET_NAME}. Building..."
             CHANGES_MADE=true

             # Install build dependencies for Ubuntu
             sudo apt-get update
             sudo apt-get install -y --no-install-recommends \
               cargo build-essential git gcc g++ make \
               libxkbcommon-dev libpipewire-0.3-dev libdbus-1-dev \
               libssl-dev pkg-config libwayland-dev ca-certificates \
               just

             # Verify just is available
             if ! command -v just >/dev/null 2>&1; then
               echo "::error:: just installation failed"
               exit 1
             fi

             REPO_DIR="/tmp/${APPLET_NAME}"
             rm -rf "${REPO_DIR}"
             git clone --depth 1 "${APPLET_URL}" "${REPO_DIR}"

             export CARGO_HOME="/tmp/cargo"
             export CARGO_TARGET_DIR="/tmp/cargo-target"
             export JUST_COLOR=never
             mkdir -p "$CARGO_HOME" "$CARGO_TARGET_DIR"

             # Build with timeout to prevent hanging
             (
               set -e
               trap "popd >/dev/null 2>/dev/null || true" EXIT
               pushd "${REPO_DIR}" >/dev/null
               
               # Check if we have a justfile and what build targets are available
               echo "Available just targets:"
               just --list 2>/dev/null || echo "No justfile found"
               
               # Prefer 'just build-release' if present, otherwise cargo build --release
               if just --list 2>/dev/null | grep -q "build-release"; then
                   echo "Using just build-release..."
                   timeout 600 just build-release
               else
                   echo "Using cargo build --release..."
                   timeout 600 cargo build --release
               fi
               
               # Verify build succeeded by checking for target directory
               echo "Build completed. Checking for build output..."
               
               if [[ ! -d "target" ]]; then
                 echo "::error:: No target directory found - build failed"
                 echo "::error:: Build artifacts:"
                 find . -name "*.o" -o -name "*.a" -o -name "Cargo.lock" | head -5
                 exit 1
               fi
               
               # List possible binary locations
               echo "Checking target directory structure:"
               ls -la target/ 2>/dev/null || echo "No target directory"
               ls -la target/release/ 2>/dev/null || echo "No target/release directory"
               
               # Check if build actually produced any files
               if [[ ! -d "target/release" ]] || [[ -z "$(ls -A target/release/ 2>/dev/null)" ]]; then
                 echo "::error:: target/release directory is empty - build may have failed"
                 exit 1
               fi
               
               # Create applet-specific artifact directory
               APPLET_ARTIFACT_DIR="/tmp/artifacts/${APPLET_NAME}"
               mkdir -p "$APPLET_ARTIFACT_DIR"
              
               # Search for actual binary files (exclude source files, translations, etc.)
               echo "Searching for cosmic binaries..."
               BINARY_NAME=""
               
               # Function to check if file is likely a binary (not source/config)
               is_binary() {
                 local file="$1"
                 # Must be executable, regular file, and larger than 1MB
                 [[ -x "$file" ]] && [[ -f "$file" ]] && [[ $(stat -c%s "$file" 2>/dev/null || echo 0) -gt 1048576 ]]
               }
               
               # Try standard target/release first
               if [[ -d "target/release" ]]; then
                 echo "Searching in target/release..."
                 while IFS= read -r -d '' file; do
                   if is_binary "$file"; then
                     BINARY_NAME="$file"
                     echo "Found binary in target/release: $BINARY_NAME"
                     break
                   fi
                 done < <(find target/release -name "cosmic*" -type f -executable ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" 2>/dev/null)
               fi
               
               # If not found, search in subdirectories
               if [[ -z "$BINARY_NAME" ]]; then
                 echo "Searching in subdirectories..."
                 while IFS= read -r -d '' file; do
                   if is_binary "$file"; then
                     BINARY_NAME="$file"
                     echo "Found binary in subdirectory: $BINARY_NAME"
                     break
                   fi
                 done < <(find . -path "*/target/release/*" -name "cosmic*" -type f -executable ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" 2>/dev/null)
               fi
               
               # Last resort: search anywhere for cosmic binaries
               if [[ -z "$BINARY_NAME" ]]; then
                 echo "Last resort search anywhere..."
                 while IFS= read -r -d '' file; do
                   if is_binary "$file"; then
                   BINARY_NAME="$file"
                   echo "Found binary anywhere: $BINARY_NAME"
                   break
                 fi
                 done < <(find . -name "cosmic*" -type f -executable ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" 2>/dev/null)
               fi
               
               # Validate we found a binary
               if [[ -z "$BINARY_NAME" || ! -f "$BINARY_NAME" ]]; then
                 echo "::error:: No cosmic binary found after build"
                 echo "::error:: All cosmic files found:"
                 find . -name "cosmic*" -type f | head -10
                 echo "::error:: Target directory contents:"
                 ls -la target/release/ 2>/dev/null || echo "Cannot list target/release"
                 echo "::error:: All executable files in target/release:"
                 find target/release -type f -executable 2>/dev/null | head -10
                 echo "::error:: File sizes in target/release:"
                 find target/release -type f -exec ls -lh {} \; 2>/dev/null | head -10
                 exit 1
               fi
              
              echo "Final binary: $BINARY_NAME"
              chmod +x "$BINARY_NAME"
              if [[ -n "$BINARY_NAME" && -f "$BINARY_NAME" ]]; then
                  BINARY_BASENAME=$(basename "$BINARY_NAME")
                  cp "$BINARY_NAME" "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME"
                  echo "Copied $BINARY_BASENAME to artifacts"
              else
                  echo "::error:: No binary found in target/release"
                  exit 1
              fi
              
              # Copy justfile if it exists
              if [[ -f "justfile" ]]; then
                cp justfile "$APPLET_ARTIFACT_DIR/"
                echo "Copied justfile to artifacts"
              fi
              
              # Parse entire justfile to identify all file references (excluding build commands)
              if [[ -f "justfile" ]]; then
                echo "Parsing justfile for all file references..."
                
                # Read the entire justfile content
                JUSTFILE_CONTENT=$(cat justfile)
                
                # Function to copy file/directory preserving structure
                copy_with_structure() {
                  local src="$1"
                  local dst_base="$2"
                  
                  # Skip empty strings, system paths, and non-existent paths
                  if [[ -z "$src" || "$src" =~ ^/usr || "$src" =~ ^/etc || "$src" =~ ^/var || ! -e "$src" ]]; then
                    return 0
                  fi
                  
                  local dst_path="$dst_base/$src"
                  mkdir -p "$(dirname "$dst_path")"
                  if [[ -d "$src" ]]; then
                    cp -r "$src" "$dst_path"
                    echo "Copied directory $src to artifacts (preserving structure)"
                  else
                    cp "$src" "$dst_path"
                    echo "Copied file $src to artifacts (preserving structure)"
                  fi
                }
                
                 # Extract variable assignments that might contain paths
                 echo "$JUSTFILE_CONTENT" | grep -E "^[a-zA-Z][a-zA-Z0-9_-]*\s*:=.*" | while IFS= read -r line; do
                   # Extract paths from variable assignments
                   # Pattern: desktop-src := 'res' / desktop
                   echo "$line" | grep -oE "'[^']*'|\"[^\"]*\"" | sed "s/['\"]//g" | while read -r path_part; do
                     # Skip empty strings, single quotes, and system paths
                     if [[ -n "$path_part" && "$path_part" != "'" && "$path_part" != "\"" && ! "$path_part" =~ ^/usr && ! "$path_part" =~ ^/etc && ! "$path_part" =~ ^/var ]]; then
                       copy_with_structure "$path_part" "$APPLET_ARTIFACT_DIR"
                     fi
                   done
                 done
                
                # Skip build-related targets and parse file references from non-build targets
                echo "$JUSTFILE_CONTENT" | grep -v -E "^(build|test|check|clean|run|vendor|fmt|dev|default|spellcheck|validate|flatpak)[^:]*:" | while IFS= read -r line; do
                  # Skip empty lines and comments
                  [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
                  
                   # Pattern 1: Variable references in install commands ({{bin-src}}, {{desktop-src}}, etc.)
                   echo "$line" | grep -oE '\{\{[^}]+\}\}' | sed 's/[{}]*//g' | while read -r var_name; do
                     # Skip empty variable names
                     [[ -z "$var_name" ]] && continue
                     # Look for the variable definition in the justfile
                     var_value=$(echo "$JUSTFILE_CONTENT" | grep -E "^[[:space:]]*$var_name\s*:=" | tail -1 | sed -E "s/^[[:space:]]*$var_name\s*:=\s*//" | sed "s/[[:space:]]*$//")
                     if [[ -n "$var_value" ]]; then
                       # Resolve the variable value (handle concatenations like 'res' / desktop)
                       resolved_path=$(echo "$var_value" | sed "s/'//g" | sed 's| |/|g' | sed 's|/ |//g')
                       # Skip empty resolved paths
                       [[ -n "$resolved_path" ]] && copy_with_structure "$resolved_path" "$APPLET_ARTIFACT_DIR"
                     fi
                   done
                  
                   # Pattern 2: Direct file paths in install commands
                   if echo "$line" | grep -q "install.*-D"; then
                     # Extract source files from install commands (first argument after -D)
                     install_src=$(echo "$line" | sed -E 's/.*install[^-]*-D[^[:space:]]+[[:space:]]+([^[:space:]]+).*/\1/')
                     # Skip if it's a variable reference (already handled above) or empty
                     if [[ -n "$install_src" && ! "$install_src" =~ ^\{\{ ]]; then
                       clean_src=$(echo "$install_src" | sed "s/[{}']//g")
                       [[ -n "$clean_src" ]] && copy_with_structure "$clean_src" "$APPLET_ARTIFACT_DIR"
                     fi
                   fi
                  
                   # Pattern 3: for loops with directory paths
                   if echo "$line" | grep -q "for.*in.*ls"; then
                     # Extract directory from for loops like "for size in `ls {{icons-src}}`"
                     loop_dir=$(echo "$line" | grep -oE '`ls [^`]+`' | sed 's/`ls //' | sed 's/`//' | sed 's/[{}]*//g')
                     [[ -n "$loop_dir" ]] && copy_with_structure "$loop_dir" "$APPLET_ARTIFACT_DIR"
                   fi
                  
                   # Pattern 4: Import statements
                   if echo "$line" | grep -q "import"; then
                     import_file=$(echo "$line" | grep -oE 'import "[^"]+"' | sed 's/import "//' | sed 's/"//')
                     [[ -n "$import_file" ]] && copy_with_structure "$import_file" "$APPLET_ARTIFACT_DIR"
                   fi
                done
                
                # Pattern 5: Common directories that appear in all applets
                for dir in res data i18n-json schema icons; do
                  copy_with_structure "$dir" "$APPLET_ARTIFACT_DIR"
                done
                
                 # Pattern 6: Copy any .desktop, .metainfo.xml, .svg files found anywhere (preserving structure)
                 while IFS= read -r -d '' file; do
                   copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
                 done < <(find . -name "*.desktop" -type f 2>/dev/null)
                 while IFS= read -r -d '' file; do
                   copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
                 done < <(find . -name "*.metainfo.xml" -type f 2>/dev/null)
                 while IFS= read -r -d '' file; do
                   copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
                 done < <(find . -name "*.svg" -type f 2>/dev/null)
                
                # Pattern 7: Check for install.sh scripts (like in privacy-indicator)
                if [[ -f "install.sh" ]]; then
                  copy_with_structure "install.sh" "$APPLET_ARTIFACT_DIR"
                fi
                
              else
                # Fallback: copy common directories if no justfile
                echo "No justfile found, using fallback directory detection"
                for dir in res data i18n-json schema icons; do
                  if [[ -d "$dir" ]]; then
                    cp -r "$dir" "$APPLET_ARTIFACT_DIR/"
                    echo "Copied $dir directory to artifacts (fallback)"
                  fi
                done
              fi
              
               popd >/dev/null
             ) || {
               echo "::error:: Build timed out or failed for ${APPLET_NAME}"
               exit 1
             }

            jq ".[\"${APPLET_NAME}\"] = \"${LATEST_COMMIT}\"" build/applet-versions.json > applet-versions.tmp && mv applet-versions.tmp build/applet-versions.json
            echo "::endgroup::"
          done

          echo "changes_made=${CHANGES_MADE}" >> $GITHUB_OUTPUT

      - name: Upload Applet Artifacts
        if: steps.build_applets.outputs.changes_made == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: applet-artifacts
          path: /tmp/artifacts/

      - name: Commit Updated Versions
        if: steps.build_applets.outputs.changes_made == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci(applets): Update applet versions"
          file_pattern: "build/applet-versions.json"
