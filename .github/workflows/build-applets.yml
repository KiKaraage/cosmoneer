---
name: Build and Update Applets

on:
  schedule:
    - cron: '0 0 * * 0' # Weekly on Sunday
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/build-applets.yml'

permissions:
  contents: write

jobs:
  build:
    name: Check for Applet Updates and Build
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends git jq ca-certificates

      - name: Define Applets
        id: applets
        run: |
          APPLET_JSON=$(jq -n '[
            {name: "cosmic-ext-applet-emoji-selector", url: "https://github.com/leb-kuchen/cosmic-ext-applet-emoji-selector"},
            {name: "cosmic-ext-applet-privacy-indicator", url: "https://github.com/D-Brox/cosmic-ext-applet-privacy-indicator"},
            {name: "cosmic-ext-applet-vitals", url: "https://github.com/Coinio/cosmic-ext-applet-vitals.git"},
            {name: "cosmic-applet-music-player", url: "https://github.com/Ebbo/cosmic-applet-music-player.git"},
            {name: "cosmic-ext-applet-caffeine", url: "https://github.com/tropicbliss/cosmic-ext-applet-caffeine"},
            {name: "cosmic-connect-applet", url: "https://github.com/cosmic-utils/cosmic-connect-applet.git"}
          ]')
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$APPLET_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build Applets
        id: build_applets
        run: |
          set -eoux pipefail
          CHANGES_MADE=false
          APPLET_LIST='${{ steps.applets.outputs.matrix }}'

          mkdir -p /tmp/artifacts

          for row in $(echo "${APPLET_LIST}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${row} | base64 --decode | jq -r ${1}
            }
            APPLET_NAME=$(_jq '.name')
            APPLET_URL=$(_jq '.url')

            echo "::group:: Checking ${APPLET_NAME}"
            LATEST_COMMIT=$(git ls-remote "${APPLET_URL}" HEAD | awk '{print $1}')
            CURRENT_COMMIT=$(jq -r ".[\"${APPLET_NAME}\"] // \"\"" build/applet-versions.json)

            if [ "${LATEST_COMMIT}" == "${CURRENT_COMMIT}" ]; then
              echo "${APPLET_NAME} is up to date. Skipping build."
              echo "::endgroup::"
              continue
            fi

            echo "New version detected for ${APPLET_NAME}. Building..."
            CHANGES_MADE=true

            # Install build dependencies for Ubuntu
            sudo apt-get update
            sudo apt-get install -y --no-install-recommends \
              cargo build-essential git gcc g++ make \
              libxkbcommon-dev libpipewire-0.3-dev libdbus-1-dev \
              libssl-dev pkg-config libwayland-dev ca-certificates

            # Ensure 'just' is available; if not, install via cargo
            if ! command -v just >/dev/null 2>&1; then
              echo "Installing 'just' via cargo"
              export CARGO_HOME="/tmp/cargo"
              mkdir -p "$CARGO_HOME"
              # Ensure cargo is in PATH for this shell
              export PATH="$CARGO_HOME/bin:$PATH"
              cargo install --locked just
            fi

            REPO_DIR="/tmp/${APPLET_NAME}"
            rm -rf "${REPO_DIR}"
            git clone --depth 1 "${APPLET_URL}" "${REPO_DIR}"

            export CARGO_HOME="/tmp/cargo"
            export CARGO_TARGET_DIR="/tmp/cargo-target"
            export JUST_COLOR=never
            mkdir -p "$CARGO_HOME" "$CARGO_TARGET_DIR"

            (
              set -e
              pushd "${REPO_DIR}" >/dev/null
              # Prefer 'just build-release' if present, otherwise cargo build --release
              if just --list 2>/dev/null | grep -q "build-release"; then
                  just build-release
              else
                  cargo build --release
              fi
              
              # Create applet-specific artifact directory
              APPLET_ARTIFACT_DIR="/tmp/artifacts/${APPLET_NAME}"
              mkdir -p "$APPLET_ARTIFACT_DIR"
              
              # Find and copy the built binary to artifacts
              echo "Searching for binaries in target/release..."
              ls -la target/release/ 2>/dev/null || echo "target/release directory not found"
              
              # List all cosmic* files to debug
              echo "All cosmic* files found:"
              find target/release -name "cosmic*" -type f 2>/dev/null | head -5
              
              # Check if files are executable
              echo "Checking executable permissions:"
              find target/release -name "cosmic*" -type f 2>/dev/null | while read -r file; do
                if [[ -x "$file" ]]; then
                  echo "✓ $file (executable)"
                else
                  echo "✗ $file (not executable) - making executable"
                  chmod +x "$file"
                fi
              done
              
              BINARY_NAME=$(find target/release -name "cosmic*applet*" -type f -executable 2>/dev/null | head -1)
              if [[ -z "$BINARY_NAME" ]]; then
                echo "No cosmic*applet* found, trying cosmic* pattern..."
                BINARY_NAME=$(find target/release -name "cosmic*" -type f -executable 2>/dev/null | head -1)
              fi
              
              echo "Found binary: $BINARY_NAME"
              if [[ -n "$BINARY_NAME" && -f "$BINARY_NAME" ]]; then
                  BINARY_BASENAME=$(basename "$BINARY_NAME")
                  cp "$BINARY_NAME" "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME"
                  echo "Copied $BINARY_BASENAME to artifacts"
              else
                  echo "::error:: No binary found in target/release"
                  exit 1
              fi
              
              # Copy justfile if it exists
              if [[ -f "justfile" ]]; then
                cp justfile "$APPLET_ARTIFACT_DIR/"
                echo "Copied justfile to artifacts"
              fi
              
              # Parse entire justfile to identify all file references (excluding build commands)
              if [[ -f "justfile" ]]; then
                echo "Parsing justfile for all file references..."
                
                # Read the entire justfile content
                JUSTFILE_CONTENT=$(cat justfile)
                
                # Function to copy file/directory preserving structure
                copy_with_structure() {
                  local src="$1"
                  local dst_base="$2"
                  
                  if [[ -e "$src" ]]; then
                    local dst_path="$dst_base/$src"
                    mkdir -p "$(dirname "$dst_path")"
                    if [[ -d "$src" ]]; then
                      cp -r "$src" "$dst_path"
                      echo "Copied directory $src to artifacts (preserving structure)"
                    else
                      cp "$src" "$dst_path"
                      echo "Copied file $src to artifacts (preserving structure)"
                    fi
                  fi
                }
                
                # Extract variable assignments that might contain paths
                echo "$JUSTFILE_CONTENT" | grep -E "^[a-zA-Z][a-zA-Z0-9_-]*\s*:=.*" | while IFS= read -r line; do
                  # Extract paths from variable assignments
                  # Pattern: desktop-src := 'res' / desktop
                  echo "$line" | grep -oE "'[^']*'|\"[^\"]*\"" | sed "s/['\"]//g" | while read -r path_part; do
                    copy_with_structure "$path_part" "$APPLET_ARTIFACT_DIR"
                  done
                done
                
                # Skip build-related targets and parse file references from non-build targets
                echo "$JUSTFILE_CONTENT" | grep -v -E "^(build|test|check|clean|run|vendor|fmt|dev|default|spellcheck|validate|flatpak)[^:]*:" | while IFS= read -r line; do
                  # Skip empty lines and comments
                  [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
                  
                  # Pattern 1: Variable references in install commands ({{bin-src}}, {{desktop-src}}, etc.)
                  echo "$line" | grep -oE '\{\{[^}]+\}\}' | sed 's/[{}]*//g' | while read -r var_name; do
                    # Look for the variable definition in the justfile
                    var_value=$(echo "$JUSTFILE_CONTENT" | grep -E "^[[:space:]]*$var_name\s*:=" | tail -1 | sed -E "s/^[[:space:]]*$var_name\s*:=\s*//" | sed "s/[[:space:]]*$//")
                    if [[ -n "$var_value" ]]; then
                      # Resolve the variable value (handle concatenations like 'res' / desktop)
                      resolved_path=$(echo "$var_value" | sed "s/'//g" | sed 's| |/|g' | sed 's|/ |//g')
                      copy_with_structure "$resolved_path" "$APPLET_ARTIFACT_DIR"
                    fi
                  done
                  
                  # Pattern 2: Direct file paths in install commands
                  if echo "$line" | grep -q "install.*-D"; then
                    # Extract source files from install commands (first argument after -D)
                    echo "$line" | sed -E 's/.*install[^-]*-D[^[:space:]]+[[:space:]]+([^[:space:]]+).*/\1/' | while read -r install_src; do
                      # Skip if it's a variable reference (already handled above)
                      if [[ ! "$install_src" =~ ^\{\{ ]]; then
                        clean_src=$(echo "$install_src" | sed "s/[{}']//g")
                        copy_with_structure "$clean_src" "$APPLET_ARTIFACT_DIR"
                      fi
                    done
                  fi
                  
                  # Pattern 3: for loops with directory paths
                  if echo "$line" | grep -q "for.*in.*ls"; then
                    # Extract directory from for loops like "for size in `ls {{icons-src}}`"
                    loop_dir=$(echo "$line" | grep -oE '`ls [^`]+`' | sed 's/`ls //' | sed 's/`//' | sed 's/[{}]*//g')
                    copy_with_structure "$loop_dir" "$APPLET_ARTIFACT_DIR"
                  fi
                  
                  # Pattern 4: Import statements
                  if echo "$line" | grep -q "import"; then
                    import_file=$(echo "$line" | grep -oE 'import "[^"]+"' | sed 's/import "//' | sed 's/"//')
                    copy_with_structure "$import_file" "$APPLET_ARTIFACT_DIR"
                  fi
                done
                
                # Pattern 5: Common directories that appear in all applets
                for dir in res data i18n-json schema icons; do
                  copy_with_structure "$dir" "$APPLET_ARTIFACT_DIR"
                done
                
                # Pattern 6: Copy any .desktop, .metainfo.xml, .svg files found anywhere (preserving structure)
                find . -name "*.desktop" -exec bash -c 'copy_with_structure "${1#./}" "$2"' _ {} "$APPLET_ARTIFACT_DIR" \; 2>/dev/null || true
                find . -name "*.metainfo.xml" -exec bash -c 'copy_with_structure "${1#./}" "$2"' _ {} "$APPLET_ARTIFACT_DIR" \; 2>/dev/null || true
                find . -name "*.svg" -exec bash -c 'copy_with_structure "${1#./}" "$2"' _ {} "$APPLET_ARTIFACT_DIR" \; 2>/dev/null || true
                
                # Pattern 7: Check for install.sh scripts (like in privacy-indicator)
                if [[ -f "install.sh" ]]; then
                  copy_with_structure "install.sh" "$APPLET_ARTIFACT_DIR"
                fi
                
              else
                # Fallback: copy common directories if no justfile
                echo "No justfile found, using fallback directory detection"
                for dir in res data i18n-json schema icons; do
                  if [[ -d "$dir" ]]; then
                    cp -r "$dir" "$APPLET_ARTIFACT_DIR/"
                    echo "Copied $dir directory to artifacts (fallback)"
                  fi
                done
              fi
              
              popd >/dev/null
            )

            jq ".[\"${APPLET_NAME}\"] = \"${LATEST_COMMIT}\"" build/applet-versions.json > applet-versions.tmp && mv applet-versions.tmp build/applet-versions.json
            echo "::endgroup::"
          done

          echo "changes_made=${CHANGES_MADE}" >> $GITHUB_OUTPUT

      - name: Upload Applet Artifacts
        if: steps.build_applets.outputs.changes_made == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: applet-artifacts
          path: /tmp/artifacts/

      - name: Commit Updated Versions
        if: steps.build_applets.outputs.changes_made == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci(applets): Update applet versions"
          file_pattern: "build/applet-versions.json"
