---
name: Applet Management
run-name: "${{ github.event_name == 'schedule' && 'Weekly Applet Check' || github.event_name == 'workflow_dispatch' && (github.event.inputs.force_all == 'true' && 'Force Build All Applets' || github.event.inputs.applet_name && format('Build {0}', github.event.inputs.applet_name) || 'Check Applet Updates') }}"

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: "Run test mode instead of full build"
        required: false
        default: false
        type: boolean
      force_all:
        description: "Force build all applets"
        required: false
        default: false
        type: boolean
      applet_name:
        description: "Specific applet to build (optional)"
        required: false
        type: choice
        options:
          - "cosmic-ext-applet-emoji-selector"
          - "cosmic-ext-applet-vitals"
          - "cosmic-applet-music-player"
          - "cosmic-ext-applet-caffeine"
          - "cosmic-connect-applet"
          - "cosmic-ext-applet-clipboard-manager"
          - "cosmic-ext-applet-ollama"
          - "cosmic-ext-alternative-startup"
          - "cosmic-ext-bg-theme"
          - "wf-recorder-gui"
          - "prtsc-wayland"
          - "niri_window_buttons"

permissions:
  contents: write
  actions: write

jobs:
  check-updates:
    name: Check for Updates
    runs-on: ubuntu-24.04
    if: github.event_name != 'pull_request'

    outputs:
      applets_to_build: ${{ steps.check_applets.outputs.applets_to_build }}
      changes_made: ${{ steps.check_applets.outputs.changes_made }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends git jq ca-certificates

      - name: Determine Force Check
        id: force
        run: |
          if [ "${{ github.event.inputs.force_all }}" = "true" ]; then
            echo "force=true" >> $GITHUB_OUTPUT
          elif [ -n "${{ github.event.inputs.applet_name }}" ]; then
            echo "force=true" >> $GITHUB_OUTPUT
          else
            echo "force=false" >> $GITHUB_OUTPUT
          fi

      - name: Define Applets
        id: applets
        run: |
          APPLET_JSON=$(jq -n '[
            {name: "cosmic-ext-applet-emoji-selector", url: "https://github.com/leb-kuchen/cosmic-ext-applet-emoji-selector"},
            {name: "cosmic-ext-applet-vitals", url: "https://github.com/Coinio/cosmic-ext-applet-vitals.git"},
            {name: "cosmic-applet-music-player", url: "https://github.com/Ebbo/cosmic-applet-music-player.git"},
            {name: "cosmic-ext-applet-caffeine", url: "https://github.com/tropicbliss/cosmic-ext-applet-caffeine"},
            {name: "cosmic-connect-applet", url: "https://github.com/cosmic-utils/cosmic-connect-applet.git"},
            {name: "cosmic-ext-applet-clipboard-manager", url: "https://github.com/cosmic-utils/clipboard-manager"},
            {name: "cosmic-ext-applet-ollama", url: "https://github.com/cosmic-utils/cosmic-ext-applet-ollama.git"},
            {name: "cosmic-ext-alternative-startup", url: "https://github.com/Drakulix/cosmic-ext-alternative-startup.git"},
            {name: "cosmic-ext-bg-theme", url: "https://github.com/wash2/cosmic_ext_bg_theme"},
            {name: "wf-recorder-gui", url: "https://github.com/ali205412/wf-recorder-gui.git"},
            {name: "prtsc-wayland", url: "https://github.com/Amchik/prtsc-wayland"},
            {name: "niri_window_buttons", url: "https://github.com/adelmonte/niri_window_buttons"}
          ]')
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$APPLET_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Check Applets and Prepare Build List
        id: check_applets
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eoux pipefail
          CHANGES_MADE=false
          FORCE_CHECK='${{ steps.force.outputs.force }}'
          APPLET_LIST='${{ steps.applets.outputs.matrix }}'
          SPECIFIC_APPLET="${{ github.event.inputs.applet_name }}"

          # Get list of applets with successful builds (have artifacts)
          SUCCESSFUL_APPLETS=$(gh run list --workflow applet-management.yml --limit 50 --json conclusion,name -q '.[] | select(.conclusion == "success") | .name | split(" ") | .[1]' | sort | uniq | tr '\n' ' ')

          APPLETS_TO_BUILD="[]"

          for row in $(echo "${APPLET_LIST}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${row} | base64 --decode | jq -r ${1}
            }
            APPLET_NAME=$(_jq '.name')
            APPLET_URL=$(_jq '.url')

            # Skip if specific applet requested and this isn't it
            if [ -n "$SPECIFIC_APPLET" ] && [ "$APPLET_NAME" != "$SPECIFIC_APPLET" ]; then
              continue
            fi

            echo "::group:: Checking ${APPLET_NAME}"
            LATEST_COMMIT=$(git ls-remote "${APPLET_URL}" HEAD | awk '{print $1}')
            CURRENT_COMMIT=$(jq -r ".[\"${APPLET_NAME}\"] // \"\"" build/applet-versions.json)

            # Check if this applet has a successful build (artifact exists)
            if echo "$SUCCESSFUL_APPLETS" | grep -wq "$APPLET_NAME"; then
              HAS_ARTIFACT=true
            else
              HAS_ARTIFACT=false
            fi

            if [ "${FORCE_CHECK}" != "true" ] && [ "${HAS_ARTIFACT}" == "true" ] && [ "${LATEST_COMMIT}" == "${CURRENT_COMMIT}" ]; then
              echo "${APPLET_NAME} is up to date and has artifact. Skipping."
              echo "::endgroup::"
              continue
            fi

            echo "Adding ${APPLET_NAME} to build queue"
            CHANGES_MADE=true

            # Update version
            jq ".[\"${APPLET_NAME}\"] = \"${LATEST_COMMIT}\"" build/applet-versions.json > applet-versions.tmp && mv applet-versions.tmp build/applet-versions.json

            # Add to build list
            APPLETS_TO_BUILD=$(echo "$APPLETS_TO_BUILD" | jq ". + [{name: \"${APPLET_NAME}\", url: \"${APPLET_URL}\"}]")

            echo "::endgroup::"
          done

          echo "applets_to_build<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$APPLETS_TO_BUILD" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "changes_made=${CHANGES_MADE}" >> $GITHUB_OUTPUT

      - name: Commit Updated Versions
        if: steps.check_applets.outputs.changes_made == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci(applets): Update applet versions"
          file_pattern: "build/applet-versions.json"
          push_options: --force-with-lease

  build-applets:
    name: Build ${{ matrix.applet.name }}
    runs-on: ubuntu-24.04
    needs: check-updates
    if: (needs.check-updates.outputs.changes_made == 'true' || github.event_name == 'workflow_dispatch') && github.event_name != 'pull_request'

    strategy:
      matrix:
        applet: ${{ fromJson(needs.check-updates.outputs.applets_to_build) }}
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Build Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            cargo build-essential git gcc g++ make \
            libxkbcommon-dev libpipewire-0.3-dev libdbus-1-dev \
            libssl-dev pkg-config libwayland-dev ca-certificates \
            just unzip

          # Install wf-recorder for wf-recorder-gui dependency
          sudo apt-get install -y --no-install-recommends wf-recorder

      - name: Build Applet
        run: |
          set -eoux pipefail
          APPLET_NAME="${{ matrix.applet.name }}"
          APPLET_URL="${{ matrix.applet.url }}"

          mkdir -p /tmp/artifacts/${APPLET_NAME}

          echo "::group:: Building ${APPLET_NAME}"

          REPO_DIR="/tmp/${APPLET_NAME}"
          rm -rf "${REPO_DIR}"
          git clone --depth 1 "${APPLET_URL}" "${REPO_DIR}"

          export CARGO_HOME="/tmp/cargo"
          export CARGO_TARGET_DIR="/tmp/cargo-target"
          export JUST_COLOR=never
          mkdir -p "$CARGO_HOME" "$CARGO_TARGET_DIR"

          # Build with timeout to prevent hanging
          (
            set -e
            trap "popd >/dev/null 2>/dev/null || true" EXIT
            pushd "${REPO_DIR}" >/dev/null

            # Check if we have a justfile and what build targets are available
            echo "Available just targets:"
            just --list 2>/dev/null || echo "No justfile found"

            # Override name for cosmic-connect-applet to use proper naming
            if [ "${APPLET_NAME}" = "cosmic-connect-applet" ]; then
                echo "Overriding name for cosmic-connect-applet (justfile has cosmic-applet-template)..."
                export name="cosmic-connect-applet"
            else
                # Extract the name from justfile for other applets
                if [ -f "justfile" ]; then
                    export name=$(grep "^name :=" justfile | sed "s/name := '//" | sed "s/'//")
                    echo "Extracted name from justfile: $name"
                fi
            fi

            # Prefer 'just build-release' if present, otherwise cargo build --release
            if just --list 2>/dev/null | grep -q "build-release"; then
                echo "Using just build-release..."
                timeout 600 just build-release
            else
                echo "Using cargo build --release..."
                timeout 600 cargo build --release
            fi

            # Verify build succeeded by checking for target directory
            echo "Build completed. Checking for build output..."

            # Use CARGO_TARGET_DIR as the target directory
            MAIN_TARGET_DIR="$CARGO_TARGET_DIR"
            if [[ ! -d "$MAIN_TARGET_DIR/release" ]]; then
            echo "::error:: No target directory with release/ found - build may have failed"
            echo "::error:: Build artifacts:"
            find "$MAIN_TARGET_DIR" -name "*.o" -o -name "*.a" 2>/dev/null | head -5 || echo "No build artifacts found in $MAIN_TARGET_DIR"
            exit 1
            fi

            echo "Using target directory: $MAIN_TARGET_DIR"
            ls -la "$MAIN_TARGET_DIR/" 2>/dev/null || echo "Cannot list target directory"
            ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list target/release directory"

            # Check if build actually produced any files
            if [[ -z "$(ls -A "$MAIN_TARGET_DIR/release/" 2>/dev/null)" ]]; then
              echo "::error:: target/release directory is empty - build may have failed"
              exit 1
            fi

            # Create applet-specific artifact directory
            APPLET_ARTIFACT_DIR="/tmp/artifacts/${APPLET_NAME}"
            mkdir -p "$APPLET_ARTIFACT_DIR"

            # Search for actual binary files (exclude source files, translations, etc.)
            echo "Searching for cosmic binaries..."
            BINARY_NAME=""

            # Function to check if file is likely a binary (not source/config)
            is_binary() {
            local file="$1"
            # Must be regular file and larger than 100KB
            # For .so files, we don't require executable bit since they're shared libraries
            [[ -f "$file" ]] && [[ $(stat -c%s "$file" 2>/dev/null || echo 0) -gt 102400 ]] && \
            ( [[ -x "$file" ]] || [[ "$file" == *.so ]] )
            }

            # Search in the target/release directory
            echo "Searching in $MAIN_TARGET_DIR/release..."
            # First try to find the specific binary name
            if [ -n "${name:-}" ]; then
                SPECIFIC_BINARY="$MAIN_TARGET_DIR/release/$name"
                if [ -f "$SPECIFIC_BINARY" ] && is_binary "$SPECIFIC_BINARY"; then
                    BINARY_NAME="$SPECIFIC_BINARY"
                    echo "Found specific binary: $BINARY_NAME"
                fi
            fi

            # Fallback to generic search if specific binary not found
            if [ -z "$BINARY_NAME" ]; then
                echo "Specific binary not found, searching for any cosmic binaries or .so files..."
                while IFS= read -r -d \'\' file; do
                  if is_binary "$file"; then
                    BINARY_NAME="$file"
                    echo "Found binary: $BINARY_NAME"
                    break
                  fi
                done < <(find "$MAIN_TARGET_DIR/release" \( -name "cosmic*" -o -name "*.so" \) -type f ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" -print0 2>/dev/null)
            fi

            # Special case for wf-recorder-gui - look for the actual binary name
            if [ -z "$BINARY_NAME" ] && [ "${APPLET_NAME}" = "wf-recorder-gui" ]; then
                echo "Searching for wf-recorder-gui binary..."
                WF_BINARY="$MAIN_TARGET_DIR/release/wf-recorder-gui"
                if [ -f "$WF_BINARY" ] && is_binary "$WF_BINARY"; then
                    BINARY_NAME="$WF_BINARY"
                    echo "Found wf-recorder-gui binary: $BINARY_NAME"
                fi
            fi

            # Special case for prtsc-wayland - look for the actual binary name
            if [ -z "$BINARY_NAME" ] && [ "${APPLET_NAME}" = "prtsc-wayland" ]; then
                echo "Searching for prtsc-wayland binary..."
                PRTSC_BINARY="$MAIN_TARGET_DIR/release/prtsc-wayland"
                if [ -f "$PRTSC_BINARY" ] && is_binary "$PRTSC_BINARY"; then
                    BINARY_NAME="$PRTSC_BINARY"
                    echo "Found prtsc-wayland binary: $BINARY_NAME"
                fi
            fi

            # Special case for niri_window_buttons - look for specific .so file
            if [ -z "$BINARY_NAME" ] && [ "${APPLET_NAME}" = "niri_window_buttons" ]; then
                echo "Searching for niri_window_buttons .so file..."
                SPECIFIC_SO_FILE="$MAIN_TARGET_DIR/release/libniri_window_buttons.so"
                if [ -f "$SPECIFIC_SO_FILE" ]; then
                    BINARY_NAME="$SPECIFIC_SO_FILE"
                    echo "Found niri_window_buttons .so file: $BINARY_NAME"
                    # For niri_window_buttons, copy .so file directly to artifact root
                    cp "$SPECIFIC_SO_FILE" "$APPLET_ARTIFACT_DIR/libniri_window_buttons.so"
                    echo "Copied .so file directly to artifact root"
                else
                    echo "Error: libniri_window_buttons.so not found in target directory"
                    exit 1
                fi
            fi

            # Validate we found a binary
            if [[ -z "$BINARY_NAME" || ! -f "$BINARY_NAME" ]]; then
                echo "::error:: No cosmic binary found after build"
                echo "::error:: All cosmic files found:"
                find "$MAIN_TARGET_DIR/release" -name "cosmic*" -type f | head -10
                echo "::error:: Target directory contents:"
                ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list $MAIN_TARGET_DIR/release"
                echo "::error:: All executable files in $MAIN_TARGET_DIR/release:"
                find "$MAIN_TARGET_DIR/release" -type f -executable 2>/dev/null | head -10
                echo "::error:: File sizes in $MAIN_TARGET_DIR/release:"
                find "$MAIN_TARGET_DIR/release" -type f -exec ls -lh {} \; 2>/dev/null | head -10
                exit 1
            fi

           echo "Final binary: $BINARY_NAME"
           chmod +x "$BINARY_NAME"
           if [[ -n "$BINARY_NAME" && -f "$BINARY_NAME" ]]; then
           BINARY_BASENAME=$(basename "$BINARY_NAME")
           cp "$BINARY_NAME" "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME"
           echo "Copied $BINARY_BASENAME to artifacts"

             # Rename binary to match expected applet name for special case applets
             case "${APPLET_NAME}" in
                "cosmic-connect-applet")
                    if [[ "$BINARY_BASENAME" != "cosmic-connect-applet" ]]; then
                        mv "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME" "$APPLET_ARTIFACT_DIR/cosmic-connect-applet"
                        echo "Renamed binary to cosmic-connect-applet"
                    fi
                    ;;
                "cosmic-ext-applet-ollama")
                    if [[ "$BINARY_BASENAME" != "cosmic-ext-applet-ollama" ]]; then
                        mv "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME" "$APPLET_ARTIFACT_DIR/cosmic-ext-applet-ollama"
                        echo "Renamed binary to cosmic-ext-applet-ollama"
                    fi
                    ;;
                "cosmic-ext-alternative-startup")
                    if [[ "$BINARY_BASENAME" != "cosmic-ext-alternative-startup" ]]; then
                        mv "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME" "$APPLET_ARTIFACT_DIR/cosmic-ext-alternative-startup"
                        echo "Renamed binary to cosmic-ext-alternative-startup"
                    fi
                    ;;
                "cosmic-ext-bg-theme")
                    if [[ "$BINARY_BASENAME" != "cosmic-ext-bg-theme" ]]; then
                        mv "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME" "$APPLET_ARTIFACT_DIR/cosmic-ext-bg-theme"
                        echo "Renamed binary to cosmic-ext-bg-theme"
                    fi
                    # Ensure desktop file is copied
                    if [[ -f "res/cosmic.ext.BgTheme.desktop" ]]; then
                        cp "res/cosmic.ext.BgTheme.desktop" "$APPLET_ARTIFACT_DIR/"
                        echo "Copied desktop file to artifacts"
                    fi
                    ;;
                "wf-recorder-gui")
                    if [[ -f "wf-recorder-gui.desktop" ]]; then
                        cp "wf-recorder-gui.desktop" "$APPLET_ARTIFACT_DIR/"
                        echo "Copied desktop file to artifacts"
                    fi
                    ;;
                "prtsc-wayland")
                    if [[ "$BINARY_BASENAME" != "prtsc-wayland" ]]; then
                        mv "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME" "$APPLET_ARTIFACT_DIR/prtsc-wayland"
                        echo "Renamed binary to prtsc-wayland"
                    fi
                    ;;
                "niri_window_buttons")
                    ;;
              esac
            else
              echo "::error:: No binary found in $MAIN_TARGET_DIR/release"
              exit 1
            fi

           # Copy justfile if it exists
           if [[ -f "justfile" ]]; then
             cp justfile "$APPLET_ARTIFACT_DIR/"
             echo "Copied justfile to artifacts"
           fi

           # Parse entire justfile to identify all file references (excluding build commands)
           if [[ -f "justfile" ]]; then
             echo "Parsing justfile for all file references..."

             # Read the entire justfile content
             JUSTFILE_CONTENT=$(cat justfile)

             # Function to copy file/directory preserving structure
             copy_with_structure() {
               local src="$1"
               local dst_base="$2"

               # Skip empty strings, system paths, and non-existent paths
               if [[ -z "$src" || "$src" =~ ^/usr || "$src" =~ ^/etc || "$src" =~ ^/var || ! -e "$src" ]]; then
                 return 0
               fi

               local dst_path="$dst_base/$src"
               mkdir -p "$(dirname "$dst_path")"
               if [[ -d "$src" ]]; then
                 cp -r "$src" "$dst_path"
                 echo "Copied directory $src to artifacts (preserving structure)"
               else
                 cp "$src" "$dst_path"
                 echo "Copied file $src to artifacts (preserving structure)"
               fi
             }

              # Extract variable assignments that might contain paths
              echo "$JUSTFILE_CONTENT" | grep -E "^[a-zA-Z][a-zA-Z0-9_-]*\s*:=.*" | while IFS= read -r line; do
                # Extract paths from variable assignments
                # Pattern: desktop-src := 'res' / desktop
                echo "$line" | grep -oE "'[^']*'|\"[^\"]*\"" | sed "s/['\"]//g" > /tmp/paths.txt
                while IFS= read -r path_part; do
                  # Skip empty strings, single quotes, and system paths
                  if [[ -n "$path_part" && "$path_part" != "'" && "$path_part" != "\"" && ! "$path_part" =~ ^/usr && ! "$path_part" =~ ^/etc && ! "$path_part" =~ ^/var ]]; then
                    copy_with_structure "$path_part" "$APPLET_ARTIFACT_DIR"
                  fi
                done < /tmp/paths.txt
              done

             # Skip build-related targets and parse file references from non-build targets
             echo "$JUSTFILE_CONTENT" | grep -v -E "^(build|test|check|clean|run|vendor|fmt|dev|default|spellcheck|validate|flatpak)[^:]*:" | while IFS= read -r line; do
               # Skip empty lines and comments
               [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

                # Pattern 1: Variable references in install commands ({{bin-src}}, {{desktop-src}}, etc.)
                echo "$line" | grep -oE '\{\{[^}]+\}\}' | sed 's/[{}]*//g' | while read -r var_name; do
                  # Skip empty variable names
                  [[ -z "$var_name" ]] && continue
                  # Look for the variable definition in the justfile
                  var_value=$(echo "$JUSTFILE_CONTENT" | grep -E "^[[:space:]]*$var_name\s*:=" | tail -1 | sed -E "s/^[[:space:]]*$var_name\s*:=\s*//" | sed "s/[[:space:]]*$//")
                  if [[ -n "$var_value" ]]; then
                    # Resolve the variable value (handle concatenations like 'res' / desktop)
                    resolved_path=$(echo "$var_value" | sed "s/'//g" | sed "s| |/|g" | sed "s|/ |//g")
                    # Skip empty resolved paths
                    [[ -n "$resolved_path" ]] && copy_with_structure "$resolved_path" "$APPLET_ARTIFACT_DIR"

                    # Special handling for id variable - also look for id.desktop and id.metainfo.xml
                    if [[ "$var_name" == "id" && -n "$resolved_path" ]]; then
                      echo "Found id variable: $resolved_path, looking for associated files..."
                      # Look for desktop file with id name
                      for dir in data res; do
                        if [[ -f "$dir/$resolved_path.desktop" ]]; then
                          copy_with_structure "$dir/$resolved_path.desktop" "$APPLET_ARTIFACT_DIR"
                        fi
                        if [[ -f "$dir/$resolved_path.metainfo.xml" ]]; then
                          copy_with_structure "$dir/$resolved_path.metainfo.xml" "$APPLET_ARTIFACT_DIR"
                        fi
                      done
                    fi
                  fi
                done

                # Pattern 2: Direct file paths in install commands
                if echo "$line" | grep -q "install.*-D"; then
                  # Extract source files from install commands (first argument after -D)
                  install_src=$(echo "$line" | sed -E 's/.*install[^-]*-D[^[:space:]]+[[:space:]]+([^[:space:]]+).*/\1/')

                  # Handle variable substitution in install paths
                  if [[ -n "$install_src" ]]; then
                    # Replace {{id}} and other variables with their actual values
                    resolved_src="$install_src"
                    while IFS= read -r var_name; do
                      var_value=$(echo "$JUSTFILE_CONTENT" | grep -E "^[[:space:]]*$var_name\s*:=" | tail -1 | sed -E "s/^[[:space:]]*$var_name\s*:=\s*//" | sed "s/[[:space:]]*$//" | sed "s/'//g")
                      if [[ -n "$var_value" ]]; then
                        resolved_src=$(echo "$resolved_src" | sed "s/{{$var_name}}/$var_value/g")
                      fi
                    done < <(echo "$install_src" | grep -oE '\{\{[^}]+\}\}' | sed 's/[{}]*//g')

                    # Skip if it's still a variable reference or empty
                    if [[ -n "$resolved_src" && ! "$resolved_src" =~ ^\{\{ ]]; then
                      clean_src=$(echo "$resolved_src" | sed "s/[{}']//g")
                      [[ -n "$clean_src" ]] && copy_with_structure "$clean_src" "$APPLET_ARTIFACT_DIR"
                    fi
                  fi
                fi

                # Pattern 3: for loops with directory paths
                if echo "$line" | grep -q "for.*in.*ls"; then
                  # Extract directory from for loops like "for size in `ls {{icons-src}}`"
                  loop_dir=$(echo "$line" | sed 's/`ls //' | sed 's/`//' | sed 's/[{}]*//g')
                  [[ -n "$loop_dir" ]] && copy_with_structure "$loop_dir" "$APPLET_ARTIFACT_DIR"
                fi

                # Pattern 4: Import statements
                if echo "$line" | grep -q "import"; then
                  import_file=$(echo "$line" | grep -oE 'import "[^"]+"' | sed 's/import "//' | sed 's/"//')
                  [[ -n "$import_file" ]] && copy_with_structure "$import_file" "$APPLET_ARTIFACT_DIR"
                fi
             done

             # Pattern 5: Common directories that appear in all applets
             for dir in res data i18n-json schema icons; do
               copy_with_structure "$dir" "$APPLET_ARTIFACT_DIR"
             done

               # Pattern 6: Copy any .desktop, .metainfo.xml, .svg files found anywhere (preserving structure)
               while IFS= read -r -d '' file; do
                 copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
               done < <(find . -name "*.desktop" -type f 2>/dev/null)
               while IFS= read -r -d '' file; do
                 copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
               done < <(find . -name "*.metainfo.xml" -type f 2>/dev/null)
               while IFS= read -r -d '' file; do
                 copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
               done < <(find . -name "*.svg" -type f 2>/dev/null)

              # Pattern 7: Handle schema installation for applets that have install-schema target
              if just --list 2>/dev/null | grep -q "install-schema"; then
                echo "Found install-schema target, setting up schema installation..."

                # Extract id variable from justfile for schema path
                if [ -f "justfile" ]; then
                  SCHEMA_ID=$(grep "^id :=" justfile | sed "s/id := '//" | sed "s/'//")
                  echo "Schema ID found: $SCHEMA_ID"

                  # Create schema installation script
                  printf '#!/bin/bash\nset -euo pipefail\n\n# Schema installation script for ${APPLET_NAME}\nmkdir -p "$HOME/.config/cosmic/%s/v1/"\nif [ -d "data/schema" ]; then\n  cp data/schema/* "$HOME/.config/cosmic/%s/v1/"\n  echo "Schema files installed to $HOME/.config/cosmic/%s/v1/"\nelse\n  echo "No data/schema directory found"\nfi\n' "$SCHEMA_ID" "$SCHEMA_ID" "$SCHEMA_ID" > "$APPLET_ARTIFACT_DIR/install-schema.sh"
                  chmod +x "$APPLET_ARTIFACT_DIR/install-schema.sh"
                  echo "Created schema installation script"
                fi
              fi

               # Pattern 8: Specialized icon handling for unique applets
               echo "Setting up specialized icon handling for ${APPLET_NAME}..."
               case "${APPLET_NAME}" in
                 "cosmic-ext-applet-clipboard-manager")
                   # Handle symbolic icon pattern
                   CLIPBOARD_APPID="io.github.cosmic_utils.cosmic-ext-applet-clipboard-manager"
                   if [[ -f "res/app_icon.svg" ]]; then
                     mkdir -p "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps"
                     cp "res/app_icon.svg" "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps/${CLIPBOARD_APPID}-symbolic.svg"
                     echo "Copied clipboard manager symbolic icon"
                   fi
                   ;;
                 "cosmic-ext-applet-vitals")
                   # Handle vitals icon pattern
                   VITALS_APPID="dev.eidolon.cosmic-ext-applet-vitals"
                   if [[ -f "res/icons/${VITALS_APPID}.svg" ]]; then
                     mkdir -p "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps"
                     cp "res/icons/${VITALS_APPID}.svg" "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps/${VITALS_APPID}.svg"
                     echo "Copied vitals icon"
                   fi
                   ;;
                 "cosmic-connect-applet")
                   # Handle multi-size icons for connect applet
                   CONNECT_APPID="com.example.CosmicAppletTemplate"
                   if [[ -d "res/icons/hicolor" ]]; then
                     mkdir -p "$APPLET_ARTIFACT_DIR/share/icons/hicolor"
                     cp -r "res/icons/hicolor/"* "$APPLET_ARTIFACT_DIR/share/icons/hicolor/"
                     echo "Copied connect applet multi-size icons"
                     # Rename icons if needed to match actual applet name
                     find "$APPLET_ARTIFACT_DIR/share/icons/hicolor" -name "${CONNECT_APPID}.svg" -exec bash -c 'mv "$1" "${1//CosmicAppletTemplate/cosmic-connect-applet}"' _ {} \;
                   fi
                   ;;
                 "cosmic-applet-music-player")
                   # Handle multi-size icons for music player
                   MUSIC_APPID="com.github.MusicPlayer"
                   if [[ -d "res/icons/hicolor" ]]; then
                     mkdir -p "$APPLET_ARTIFACT_DIR/share/icons/hicolor"
                     cp -r "res/icons/hicolor/"* "$APPLET_ARTIFACT_DIR/share/icons/hicolor/"
                     echo "Copied music player multi-size icons"
                   fi
                   ;;
                 "cosmic-ext-applet-caffeine")
                   # Handle dual icons for caffeine applet
                   CAFFEINE_APPID="net.tropicbliss.CosmicExtAppletCaffeine"
                   if [[ -f "res/${CAFFEINE_APPID}-empty.svg" ]]; then
                     mkdir -p "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps"
                     cp "res/${CAFFEINE_APPID}-empty.svg" "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps/"
                     echo "Copied caffeine empty icon"
                   fi
                   if [[ -f "res/${CAFFEINE_APPID}-full.svg" ]]; then
                     mkdir -p "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps"
                     cp "res/${CAFFEINE_APPID}-full.svg" "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps/"
                     echo "Copied caffeine full icon"
                   fi
                   ;;
               esac

               # Pattern 9: Check for install.sh scripts (like in privacy-indicator)
               if [[ -f "install.sh" ]]; then
                 copy_with_structure "install.sh" "$APPLET_ARTIFACT_DIR"
               fi

            else
             # Fallback: copy common directories if no justfile
             echo "No justfile found, using fallback directory detection"
             for dir in res data i18n-json schema icons; do
               if [[ -d "$dir" ]]; then
                 cp -r "$dir" "$APPLET_ARTIFACT_DIR/"
                 echo "Copied $dir directory to artifacts (fallback)"
               fi
             done
           fi

            popd >/dev/null
          ) || {
            echo "::error:: Build timed out or failed for ${APPLET_NAME}"
            exit 1
          }

          echo "::endgroup::"

      - name: Upload Applet Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.applet.name }}
          path: /tmp/artifacts/${{ matrix.applet.name }}/

  test-applet-workflow:
    name: Test Applet Workflow
    runs-on: ubuntu-24.04
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.test_mode == 'true'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Build Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            cargo build-essential git gcc g++ make \
            libxkbcommon-dev libpipewire-0.3-dev libdbus-1-dev \
            libssl-dev pkg-config libwayland-dev ca-certificates \
            just unzip

          # Install wf-recorder for wf-recorder-gui dependency
          sudo apt-get install -y --no-install-recommends wf-recorder

      - name: Test Build a Sample Applet
        run: |
          set -eoux pipefail

          # Test with cosmic-ext-applet-clipboard-manager as a sample
          APPLET_NAME="cosmic-ext-applet-clipboard-manager"
          APPLET_URL="https://github.com/cosmic-utils/clipboard-manager"

          mkdir -p /tmp/artifacts/${APPLET_NAME}

          echo "::group:: Testing ${APPLET_NAME} build"

          REPO_DIR="/tmp/${APPLET_NAME}"
          rm -rf "${REPO_DIR}"
          git clone --depth 1 "${APPLET_URL}" "${REPO_DIR}"

          export CARGO_HOME="/tmp/cargo"
          export CARGO_TARGET_DIR="/tmp/cargo-target"
          export JUST_COLOR=never
          mkdir -p "$CARGO_HOME" "$CARGO_TARGET_DIR"

          # Build with timeout to prevent hanging
          (
            set -e
            trap "popd >/dev/null 2>/dev/null || true" EXIT
            pushd "${REPO_DIR}" >/dev/null

            # Check if we have a justfile and what build targets are available
            echo "Available just targets:"
            just --list 2>/dev/null || echo "No justfile found"

            # Override name for cosmic-connect-applet to use proper naming
            if [ "${APPLET_NAME}" = "cosmic-connect-applet" ]; then
                echo "Overriding name for cosmic-connect-applet (justfile has cosmic-applet-template)..."
                export name="cosmic-connect-applet"
            else
                # Extract the name from justfile for other applets
                if [ -f "justfile" ]; then
                    export name=$(grep "^name :=" justfile | sed "s/name := '//" | sed "s/'//")
                    echo "Extracted name from justfile: $name"
                fi
            fi

            # Prefer 'just build-release' if present, otherwise cargo build --release
            if just --list 2>/dev/null | grep -q "build-release"; then
                echo "Using just build-release..."
                timeout 600 just build-release
            else
                echo "Using cargo build --release..."
                timeout 600 cargo build --release
            fi

            # Create applet-specific artifact directory
            APPLET_ARTIFACT_DIR="/tmp/artifacts/${APPLET_NAME}"
            mkdir -p "$APPLET_ARTIFACT_DIR"

            # Use CARGO_TARGET_DIR as the target directory
            MAIN_TARGET_DIR="$CARGO_TARGET_DIR"

            # Search for actual binary files (exclude source files, translations, etc.)
            echo "Searching for cosmic binaries..."
            BINARY_NAME=""

            # Function to check if file is likely a binary (not source/config)
            is_binary() {
            local file="$1"
            # Must be regular file and larger than 100KB
            # For .so files, we don't require executable bit since they're shared libraries
            [[ -f "$file" ]] && [[ $(stat -c%s "$file" 2>/dev/null || echo 0) -gt 102400 ]] && \
            ( [[ -x "$file" ]] || [[ "$file" == *.so ]] )
            }

            # Search in the target/release directory
            echo "Searching in $MAIN_TARGET_DIR/release..."
            # First try to find the specific binary name
            if [ -n "${name:-}" ]; then
                SPECIFIC_BINARY="$MAIN_TARGET_DIR/release/$name"
                if [ -f "$SPECIFIC_BINARY" ] && is_binary "$SPECIFIC_BINARY"; then
                    BINARY_NAME="$SPECIFIC_BINARY"
                    echo "Found specific binary: $BINARY_NAME"
                fi
            fi

            # Fallback to generic search if specific binary not found
            if [ -z "$BINARY_NAME" ]; then
                echo "Specific binary not found, searching for any cosmic binaries or .so files..."
                while IFS= read -r -d '' file; do
                  if is_binary "$file"; then
                    BINARY_NAME="$file"
                    echo "Found binary: $BINARY_NAME"
                    break
                  fi
                done < <(find "$MAIN_TARGET_DIR/release" \( -name "cosmic*" -o -name "*.so" \) -type f ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" -print0 2>/dev/null)
            fi

           echo "Final binary: $BINARY_NAME"
           chmod +x "$BINARY_NAME"
           if [[ -n "$BINARY_NAME" && -f "$BINARY_NAME" ]]; then
           BINARY_BASENAME=$(basename "$BINARY_NAME")
           cp "$BINARY_NAME" "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME"
           echo "Copied $BINARY_BASENAME to artifacts"
           fi

           # Copy justfile if it exists
           if [[ -f "justfile" ]]; then
             cp justfile "$APPLET_ARTIFACT_DIR/"
             echo "Copied justfile to artifacts"
           fi

           # Test icon handling for clipboard manager
           if [[ "${APPLET_NAME}" == "cosmic-ext-applet-clipboard-manager" ]]; then
             CLIPBOARD_APPID="io.github.cosmic_utils.cosmic-ext-applet-clipboard-manager"
             if [[ -f "res/app_icon.svg" ]]; then
               mkdir -p "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps"
               cp "res/app_icon.svg" "$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps/${CLIPBOARD_APPID}-symbolic.svg"
               echo "Copied clipboard manager symbolic icon"
             fi
           fi

            popd >/dev/null
          ) || {
            echo "::error:: Build timed out or failed for ${APPLET_NAME}"
            exit 1
          }

          echo "::endgroup::"

      - name: Validate Build Output
        run: |
          set -eoux pipefail

          echo "::group:: Validating build output"

          # Use CARGO_TARGET_DIR as the target directory
          MAIN_TARGET_DIR="/tmp/cargo-target"

          # Verify build succeeded by checking for target directory
          if [[ ! -d "$MAIN_TARGET_DIR/release" ]]; then
            echo "::error:: No target directory with release/ found - build may have failed"
            echo "::error:: Build artifacts:"
            find "$MAIN_TARGET_DIR" -name "*.o" -o -name "*.a" 2>/dev/null | head -5 || echo "No build artifacts found in $MAIN_TARGET_DIR"
            exit 1
          fi

          echo "Using target directory: $MAIN_TARGET_DIR"
          ls -la "$MAIN_TARGET_DIR/" 2>/dev/null || echo "Cannot list target directory"
          ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list target/release directory"

          # Check if build actually produced any files
          if [[ -z "$(ls -A "$MAIN_TARGET_DIR/release/" 2>/dev/null)" ]]; then
            echo "::error:: target/release directory is empty - build may have failed"
            exit 1
          fi

          # Validate we found a binary
          BINARY_NAME=""
          if [ -n "${name:-}" ]; then
              SPECIFIC_BINARY="$MAIN_TARGET_DIR/release/$name"
              if [ -f "$SPECIFIC_BINARY" ]; then
                  BINARY_NAME="$SPECIFIC_BINARY"
              fi
          fi

          if [ -z "$BINARY_NAME" ]; then
              while IFS= read -r -d '' file; do
                if [[ -f "$file" ]] && [[ $(stat -c%s "$file" 2>/dev/null || echo 0) -gt 102400 ]] && \
                  ( [[ -x "$file" ]] || [[ "$file" == *.so ]] ); then
                  BINARY_NAME="$file"
                  break
                fi
            done < <(find "$MAIN_TARGET_DIR/release" \( -name "cosmic*" -o -name "*.so" \) -type f ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" -print0 2>/dev/null)
          fi

          if [[ -z "$BINARY_NAME" || ! -f "$BINARY_NAME" ]]; then
            echo "::error:: No cosmic binary found after build"
            echo "::error:: All cosmic files found:"
            find "$MAIN_TARGET_DIR/release" -name "cosmic*" -type f | head -10
            echo "::error:: Target directory contents:"
            ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list $MAIN_TARGET_DIR/release"
            echo "::error:: All executable files in $MAIN_TARGET_DIR/release:"
            find "$MAIN_TARGET_DIR/release" -type f -executable 2>/dev/null | head -10
            echo "::error:: File sizes in $MAIN_TARGET_DIR/release:"
            find "$MAIN_TARGET_DIR/release" -type f -exec ls -lh {} \; 2>/dev/null | head -10
            exit 1
          fi

          echo "✅ Build validation passed - binary found: $(basename "$BINARY_NAME")"
          echo "::endgroup::"

      - name: Validate Test Build Output
        run: |
          set -eoux pipefail
          APPLET_ARTIFACT_DIR="/tmp/artifacts/cosmic-ext-applet-clipboard-manager"

          echo "::group:: Validating build output"

          # Check if binary exists and is executable
          if [[ -f "$APPLET_ARTIFACT_DIR/cosmic-ext-applet-clipboard-manager" ]]; then
            echo "✅ Binary found: cosmic-ext-applet-clipboard-manager"
            if [[ -x "$APPLET_ARTIFACT_DIR/cosmic-ext-applet-clipboard-manager" ]]; then
              echo "✅ Binary is executable"
            else
              echo "❌ Binary is not executable"
              exit 1
            fi
          else
            echo "❌ Binary not found"
            exit 1
          fi

          # Check if justfile was copied
          if [[ -f "$APPLET_ARTIFACT_DIR/justfile" ]]; then
            echo "✅ Justfile copied"
          else
            echo "❌ Justfile not found"
            exit 1
          fi

          # Check if symbolic icon was created properly
          CLIPBOARD_APPID="io.github.cosmic_utils.cosmic-ext-applet-clipboard-manager"
          ICON_PATH="$APPLET_ARTIFACT_DIR/share/icons/hicolor/scalable/apps/${CLIPBOARD_APPID}-symbolic.svg"
          if [[ -f "$ICON_PATH" ]]; then
            echo "✅ Symbolic icon found: ${CLIPBOARD_APPID}-symbolic.svg"
          else
            echo "❌ Symbolic icon not found at $ICON_PATH"
            exit 1
          fi

          # Check if desktop file exists
          if find "$APPLET_ARTIFACT_DIR" -name "*.desktop" -type f | grep -q .; then
            echo "✅ Desktop file found"
          else
            echo "❌ Desktop file not found"
            exit 1
          fi

          # Check if metainfo file exists
          if find "$APPLET_ARTIFACT_DIR" -name "*.metainfo.xml" -type f | grep -q .; then
            echo "✅ Metainfo file found"
          else
            echo "❌ Metainfo file not found"
            exit 1
          fi

          echo "::endgroup::"
          echo "✅ All validations passed!"

      - name: Cleanup Test Build
        if: always()
        run: |
          echo "::group:: Cleaning up test build"
          rm -rf /tmp/artifacts/cosmic-ext-applet-clipboard-manager
          rm -rf /tmp/cosmic-ext-applet-clipboard-manager
          rm -rf /tmp/cargo /tmp/cargo-target
          echo "✅ Cleanup completed"
