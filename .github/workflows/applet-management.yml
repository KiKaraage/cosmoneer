---
name: Applet Management
run-name: "${{ github.event_name == 'schedule' && 'Weekly Applet Check' || github.event_name == 'workflow_dispatch' && (github.event.inputs.force_all == 'true' && 'Force Build All Applets' || github.event.inputs.applet_name && format('Build {0}', github.event.inputs.applet_name) || 'Check Applet Updates') }}"

on:
  schedule:
  - cron: '0 0 * * 0'  # Weekly on Sunday
  workflow_dispatch:
    inputs:
      force_all:
        description: 'Force build all applets'
        required: false
        default: 'false'
        type: boolean
      applet_name:
        description: 'Specific applet to build (optional)'
        required: false
        type: string

permissions:
  contents: write
  actions: write

jobs:
  check-updates:
    name: Check for Updates
    runs-on: ubuntu-24.04
    

    outputs:
      applets_to_build: ${{ steps.check_applets.outputs.applets_to_build }}
      changes_made: ${{ steps.check_applets.outputs.changes_made }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends git jq ca-certificates

      - name: Determine Force Check
        id: force
        run: |
          if [ "${{ github.event.inputs.force_all }}" = "true" ]; then
            echo "force=true" >> $GITHUB_OUTPUT
          elif [ -n "${{ github.event.inputs.applet_name }}" ]; then
            echo "force=true" >> $GITHUB_OUTPUT
          else
            echo "force=false" >> $GITHUB_OUTPUT
          fi

      - name: Define Applets
        id: applets
        run: |
          APPLET_JSON=$(jq -n '[
            {name: "cosmic-ext-applet-emoji-selector", url: "https://github.com/leb-kuchen/cosmic-ext-applet-emoji-selector"},
            {name: "cosmic-ext-applet-privacy-indicator", url: "https://github.com/D-Brox/cosmic-ext-applet-privacy-indicator"},
            {name: "cosmic-ext-applet-vitals", url: "https://github.com/Coinio/cosmic-ext-applet-vitals.git"},
            {name: "cosmic-applet-music-player", url: "https://github.com/Ebbo/cosmic-applet-music-player.git"},
            {name: "cosmic-ext-applet-caffeine", url: "https://github.com/tropicbliss/cosmic-ext-applet-caffeine"},
            {name: "cosmic-connect-applet", url: "https://github.com/cosmic-utils/cosmic-connect-applet.git"},
            {name: "cosmic-ext-applet-clipboard-manager", url: "https://github.com/cosmic-utils/clipboard-manager"},
            {name: "cosmic-ext-applet-ollama", url: "https://github.com/cosmic-utils/cosmic-ext-applet-ollama.git"}
          ]')
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$APPLET_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Check Applets and Prepare Build List
        id: check_applets
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eoux pipefail
          CHANGES_MADE=false
          FORCE_CHECK='${{ steps.force.outputs.force }}'
          APPLET_LIST='${{ steps.applets.outputs.matrix }}'
          SPECIFIC_APPLET="${{ github.event.inputs.applet_name }}"

          # Get list of applets with successful builds (have artifacts)
          SUCCESSFUL_APPLETS=$(gh run list --workflow applet-management.yml --limit 50 --json conclusion,name -q '.[] | select(.conclusion == "success") | .name | split(" ") | .[1]' | sort | uniq | tr '\n' ' ')

          APPLETS_TO_BUILD="[]"

          for row in $(echo "${APPLET_LIST}" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${row} | base64 --decode | jq -r ${1}
            }
            APPLET_NAME=$(_jq '.name')
            APPLET_URL=$(_jq '.url')

            # Skip if specific applet requested and this isn't it
            if [ -n "$SPECIFIC_APPLET" ] && [ "$APPLET_NAME" != "$SPECIFIC_APPLET" ]; then
              continue
            fi

            echo "::group:: Checking ${APPLET_NAME}"
            LATEST_COMMIT=$(git ls-remote "${APPLET_URL}" HEAD | awk '{print $1}')
            CURRENT_COMMIT=$(jq -r ".[\"${APPLET_NAME}\"] // \"\"" build/applet-versions.json)

            # Check if this applet has a successful build (artifact exists)
            if echo "$SUCCESSFUL_APPLETS" | grep -wq "$APPLET_NAME"; then
              HAS_ARTIFACT=true
            else
              HAS_ARTIFACT=false
            fi

            if [ "${FORCE_CHECK}" != "true" ] && [ "${HAS_ARTIFACT}" == "true" ] && [ "${LATEST_COMMIT}" == "${CURRENT_COMMIT}" ]; then
              echo "${APPLET_NAME} is up to date and has artifact. Skipping."
              echo "::endgroup::"
              continue
            fi

            echo "Adding ${APPLET_NAME} to build queue"
            CHANGES_MADE=true

            # Update version
            jq ".[\"${APPLET_NAME}\"] = \"${LATEST_COMMIT}\"" build/applet-versions.json > applet-versions.tmp && mv applet-versions.tmp build/applet-versions.json

            # Add to build list
            APPLETS_TO_BUILD=$(echo "$APPLETS_TO_BUILD" | jq ". + [{name: \"${APPLET_NAME}\", url: \"${APPLET_URL}\"}]")

            echo "::endgroup::"
          done

          echo "applets_to_build<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$APPLETS_TO_BUILD" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "changes_made=${CHANGES_MADE}" >> $GITHUB_OUTPUT

      - name: Commit Updated Versions
        if: steps.check_applets.outputs.changes_made == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci(applets): Update applet versions"
          file_pattern: "build/applet-versions.json"

  build-applets:
    name: Build Applet
    runs-on: ubuntu-24.04
    needs: check-updates
    if: needs.check-updates.outputs.changes_made == 'true' || github.event_name == 'workflow_dispatch'
    
    strategy:
      matrix:
        applet: ${{ fromJson(needs.check-updates.outputs.applets_to_build) }}
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Build Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            cargo build-essential git gcc g++ make \
            libxkbcommon-dev libpipewire-0.3-dev libdbus-1-dev \
            libssl-dev pkg-config libwayland-dev ca-certificates \
            just unzip

      - name: Build Applet
        run: |
          set -eoux pipefail
          APPLET_NAME="${{ matrix.applet.name }}"
          APPLET_URL="${{ matrix.applet.url }}"

          mkdir -p /tmp/artifacts/${APPLET_NAME}

          echo "::group:: Building ${APPLET_NAME}"

          REPO_DIR="/tmp/${APPLET_NAME}"
          rm -rf "${REPO_DIR}"
          git clone --depth 1 "${APPLET_URL}" "${REPO_DIR}"

          export CARGO_HOME="/tmp/cargo"
          export CARGO_TARGET_DIR="/tmp/cargo-target"
          export JUST_COLOR=never
          mkdir -p "$CARGO_HOME" "$CARGO_TARGET_DIR"

          # Build with timeout to prevent hanging
          (
            set -e
            trap "popd >/dev/null 2>/dev/null || true" EXIT
            pushd "${REPO_DIR}" >/dev/null

            # Check if we have a justfile and what build targets are available
            echo "Available just targets:"
            just --list 2>/dev/null || echo "No justfile found"

            # Prefer 'just build-release' if present, otherwise cargo build --release
            if just --list 2>/dev/null | grep -q "build-release"; then
                echo "Using just build-release..."
                timeout 600 just build-release
            else
                echo "Using cargo build --release..."
                timeout 600 cargo build --release
            fi

            # Verify build succeeded by checking for target directory
            echo "Build completed. Checking for build output..."

            # Use CARGO_TARGET_DIR as the target directory
            MAIN_TARGET_DIR="$CARGO_TARGET_DIR"
            if [[ ! -d "$MAIN_TARGET_DIR/release" ]]; then
            echo "::error:: No target directory with release/ found - build may have failed"
            echo "::error:: Build artifacts:"
            find "$MAIN_TARGET_DIR" -name "*.o" -o -name "*.a" 2>/dev/null | head -5 || echo "No build artifacts found in $MAIN_TARGET_DIR"
            exit 1
            fi

            echo "Using target directory: $MAIN_TARGET_DIR"
            ls -la "$MAIN_TARGET_DIR/" 2>/dev/null || echo "Cannot list target directory"
            ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list target/release directory"

            # Check if build actually produced any files
            if [[ -z "$(ls -A "$MAIN_TARGET_DIR/release/" 2>/dev/null)" ]]; then
              echo "::error:: target/release directory is empty - build may have failed"
              exit 1
            fi

            # Create applet-specific artifact directory
            APPLET_ARTIFACT_DIR="/tmp/artifacts/${APPLET_NAME}"
            mkdir -p "$APPLET_ARTIFACT_DIR"

            # Search for actual binary files (exclude source files, translations, etc.)
            echo "Searching for cosmic binaries..."
            BINARY_NAME=""

            # Function to check if file is likely a binary (not source/config)
            is_binary() {
            local file="$1"
            # Must be executable, regular file, and larger than 100KB
            [[ -x "$file" ]] && [[ -f "$file" ]] && [[ $(stat -c%s "$file" 2>/dev/null || echo 0) -gt 102400 ]]
            }

            # Search in the target/release directory
            echo "Searching in $MAIN_TARGET_DIR/release..."
            while IFS= read -r -d '' file; do
              if is_binary "$file"; then
                BINARY_NAME="$file"
                echo "Found binary: $BINARY_NAME"
                break
              fi
            done < <(find "$MAIN_TARGET_DIR/release" -name "cosmic*" -type f -executable ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" -print0 2>/dev/null)

            # Validate we found a binary
            if [[ -z "$BINARY_NAME" || ! -f "$BINARY_NAME" ]]; then
            echo "::error:: No cosmic binary found after build"
            echo "::error:: All cosmic files found:"
            find "$MAIN_TARGET_DIR/release" -name "cosmic*" -type f | head -10
            echo "::error:: Target directory contents:"
            ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list $MAIN_TARGET_DIR/release"
            echo "::error:: All executable files in $MAIN_TARGET_DIR/release:"
            find "$MAIN_TARGET_DIR/release" -type f -executable 2>/dev/null | head -10
            echo "::error:: File sizes in $MAIN_TARGET_DIR/release:"
            find "$MAIN_TARGET_DIR/release" -type f -exec ls -lh {} \; 2>/dev/null | head -10
            exit 1
            fi

           echo "Final binary: $BINARY_NAME"
           chmod +x "$BINARY_NAME"
           if [[ -n "$BINARY_NAME" && -f "$BINARY_NAME" ]]; then
           BINARY_BASENAME=$(basename "$BINARY_NAME")
           cp "$BINARY_NAME" "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME"
           echo "Copied $BINARY_BASENAME to artifacts"
           else
           echo "::error:: No binary found in $MAIN_TARGET_DIR/release"
           exit 1
           fi

           # Copy justfile if it exists
           if [[ -f "justfile" ]]; then
             cp justfile "$APPLET_ARTIFACT_DIR/"
             echo "Copied justfile to artifacts"
           fi

           # Parse entire justfile to identify all file references (excluding build commands)
           if [[ -f "justfile" ]]; then
             echo "Parsing justfile for all file references..."

             # Read the entire justfile content
             JUSTFILE_CONTENT=$(cat justfile)

             # Function to copy file/directory preserving structure
             copy_with_structure() {
               local src="$1"
               local dst_base="$2"

               # Skip empty strings, system paths, and non-existent paths
               if [[ -z "$src" || "$src" =~ ^/usr || "$src" =~ ^/etc || "$src" =~ ^/var || ! -e "$src" ]]; then
                 return 0
               fi

               local dst_path="$dst_base/$src"
               mkdir -p "$(dirname "$dst_path")"
               if [[ -d "$src" ]]; then
                 cp -r "$src" "$dst_path"
                 echo "Copied directory $src to artifacts (preserving structure)"
               else
                 cp "$src" "$dst_path"
                 echo "Copied file $src to artifacts (preserving structure)"
               fi
             }

              # Extract variable assignments that might contain paths
              echo "$JUSTFILE_CONTENT" | grep -E "^[a-zA-Z][a-zA-Z0-9_-]*\s*:=.*" | while IFS= read -r line; do
                # Extract paths from variable assignments
                # Pattern: desktop-src := 'res' / desktop
                echo "$line" | grep -oE "'[^']*'|\"[^\"]*\"" | sed "s/['\"]//g" | while read -r path_part; do
                  # Skip empty strings, single quotes, and system paths
                  if [[ -n "$path_part" && "$path_part" != "'" && "$path_part" != "\"" && ! "$path_part" =~ ^/usr && ! "$path_part" =~ ^/etc && ! "$path_part" =~ ^/var ]]; then
                    copy_with_structure "$path_part" "$APPLET_ARTIFACT_DIR"
                  fi
                done
              done

             # Skip build-related targets and parse file references from non-build targets
             echo "$JUSTFILE_CONTENT" | grep -v -E "^(build|test|check|clean|run|vendor|fmt|dev|default|spellcheck|validate|flatpak)[^:]*:" | while IFS= read -r line; do
               # Skip empty lines and comments
               [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

                # Pattern 1: Variable references in install commands ({{bin-src}}, {{desktop-src}}, etc.)
                echo "$line" | grep -oE '\{\{[^}]+\}\}' | sed 's/[{}]*//g' | while read -r var_name; do
                  # Skip empty variable names
                  [[ -z "$var_name" ]] && continue
                  # Look for the variable definition in the justfile
                  var_value=$(echo "$JUSTFILE_CONTENT" | grep -E "^[[:space:]]*$var_name\s*:=" | tail -1 | sed -E "s/^[[:space:]]*$var_name\s*:=\s*//" | sed "s/[[:space:]]*$//")
                  if [[ -n "$var_value" ]]; then
                    # Resolve the variable value (handle concatenations like 'res' / desktop)
                    resolved_path=$(echo "$var_value" | sed "s/'//g" | sed "s| |/|g" | sed "s|/ |//g")
                    # Skip empty resolved paths
                    [[ -n "$resolved_path" ]] && copy_with_structure "$resolved_path" "$APPLET_ARTIFACT_DIR"
                  fi
                done

                # Pattern 2: Direct file paths in install commands
                if echo "$line" | grep -q "install.*-D"; then
                  # Extract source files from install commands (first argument after -D)
                  install_src=$(echo "$line" | sed -E 's/.*install[^-]*-D[^[:space:]]+[[:space:]]+([^[:space:]]+).*/\1/')
                  # Skip if it's a variable reference (already handled above) or empty
                  if [[ -n "$install_src" && ! "$install_src" =~ ^\{\{ ]]; then
                    clean_src=$(echo "$install_src" | sed "s/[{}']//g")
                    [[ -n "$clean_src" ]] && copy_with_structure "$clean_src" "$APPLET_ARTIFACT_DIR"
                  fi
                fi

                # Pattern 3: for loops with directory paths
                if echo "$line" | grep -q "for.*in.*ls"; then
                  # Extract directory from for loops like "for size in `ls {{icons-src}}`"
                  loop_dir=$(echo "$line" | sed 's/`ls //' | sed 's/`//' | sed 's/[{}]*//g')
                  [[ -n "$loop_dir" ]] && copy_with_structure "$loop_dir" "$APPLET_ARTIFACT_DIR"
                fi

                # Pattern 4: Import statements
                if echo "$line" | grep -q "import"; then
                  import_file=$(echo "$line" | grep -oE 'import "[^"]+"' | sed 's/import "//' | sed 's/"//')
                  [[ -n "$import_file" ]] && copy_with_structure "$import_file" "$APPLET_ARTIFACT_DIR"
                fi
             done

             # Pattern 5: Common directories that appear in all applets
             for dir in res data i18n-json schema icons; do
               copy_with_structure "$dir" "$APPLET_ARTIFACT_DIR"
             done

              # Pattern 6: Copy any .desktop, .metainfo.xml, .svg files found anywhere (preserving structure)
              while IFS= read -r -d '' file; do
                copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
              done < <(find . -name "*.desktop" -type f 2>/dev/null)
              while IFS= read -r -d '' file; do
                copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
              done < <(find . -name "*.metainfo.xml" -type f 2>/dev/null)
              while IFS= read -r -d '' file; do
                copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
              done < <(find . -name "*.svg" -type f 2>/dev/null)

             # Pattern 7: Check for install.sh scripts (like in privacy-indicator)
             if [[ -f "install.sh" ]]; then
               copy_with_structure "install.sh" "$APPLET_ARTIFACT_DIR"
             fi

           else
             # Fallback: copy common directories if no justfile
             echo "No justfile found, using fallback directory detection"
             for dir in res data i18n-json schema icons; do
               if [[ -d "$dir" ]]; then
                 cp -r "$dir" "$APPLET_ARTIFACT_DIR/"
                 echo "Copied $dir directory to artifacts (fallback)"
               fi
             done
           fi

            popd >/dev/null
          ) || {
            echo "::error:: Build timed out or failed for ${APPLET_NAME}"
            exit 1
          }

          echo "::endgroup::"

      - name: Upload Applet Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.applet.name }}
          path: /tmp/artifacts/${{ matrix.applet.name }}/