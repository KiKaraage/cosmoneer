---
name: Build Applet

on:
  repository_dispatch:
    types: [build-applet]

permissions:
  contents: read

jobs:
  build:
    name: Build ${{ github.event.client_payload.applet_name }}
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            cargo build-essential git gcc g++ make \
            libxkbcommon-dev libpipewire-0.3-dev libdbus-1-dev \
            libssl-dev pkg-config libwayland-dev ca-certificates \
            just unzip

      - name: Build Applet
        run: |
          set -eoux pipefail
          APPLET_NAME="${{ github.event.client_payload.applet_name }}"
          APPLET_URL="${{ github.event.client_payload.applet_url }}"

          mkdir -p /tmp/artifacts/${APPLET_NAME}

          echo "::group:: Building ${APPLET_NAME}"

          # Install build dependencies for Ubuntu
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            cargo build-essential git gcc g++ make \
            libxkbcommon-dev libpipewire-0.3-dev libdbus-1-dev \
            libssl-dev pkg-config libwayland-dev ca-certificates \
            just

          # Verify just is available
          if ! command -v just >/dev/null 2>&1; then
            echo "::error:: just installation failed"
            exit 1
          fi

          REPO_DIR="/tmp/${APPLET_NAME}"
          rm -rf "${REPO_DIR}"
          git clone --depth 1 "${APPLET_URL}" "${REPO_DIR}"

          export CARGO_HOME="/tmp/cargo"
          export CARGO_TARGET_DIR="/tmp/cargo-target"
          export JUST_COLOR=never
          mkdir -p "$CARGO_HOME" "$CARGO_TARGET_DIR"

          # Build with timeout to prevent hanging
          (
            set -e
            trap "popd >/dev/null 2>/dev/null || true" EXIT
            pushd "${REPO_DIR}" >/dev/null

            # Check if we have a justfile and what build targets are available
            echo "Available just targets:"
            just --list 2>/dev/null || echo "No justfile found"

            # Prefer 'just build-release' if present, otherwise cargo build --release
            if just --list 2>/dev/null | grep -q "build-release"; then
                echo "Using just build-release..."
                timeout 600 just build-release
            else
                echo "Using cargo build --release..."
                timeout 600 cargo build --release
            fi

            # Verify build succeeded by checking for target directory
            echo "Build completed. Checking for build output..."

            # Use CARGO_TARGET_DIR as the target directory
            MAIN_TARGET_DIR="$CARGO_TARGET_DIR"
            if [[ ! -d "$MAIN_TARGET_DIR/release" ]]; then
            echo "::error:: No target directory with release/ found - build may have failed"
            echo "::error:: Build artifacts:"
            find "$MAIN_TARGET_DIR" -name "*.o" -o -name "*.a" 2>/dev/null | head -5 || echo "No build artifacts found in $MAIN_TARGET_DIR"
            exit 1
            fi

            echo "Using target directory: $MAIN_TARGET_DIR"
            ls -la "$MAIN_TARGET_DIR/" 2>/dev/null || echo "Cannot list target directory"
            ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list target/release directory"

            # Check if build actually produced any files
            if [[ -z "$(ls -A "$MAIN_TARGET_DIR/release/" 2>/dev/null)" ]]; then
              echo "::error:: target/release directory is empty - build may have failed"
              exit 1
            fi

            # Create applet-specific artifact directory
            APPLET_ARTIFACT_DIR="/tmp/artifacts/${APPLET_NAME}"
            mkdir -p "$APPLET_ARTIFACT_DIR"

            # Search for actual binary files (exclude source files, translations, etc.)
            echo "Searching for cosmic binaries..."
            BINARY_NAME=""

            # Function to check if file is likely a binary (not source/config)
            is_binary() {
            local file="$1"
            # Must be executable, regular file, and larger than 100KB
            [[ -x "$file" ]] && [[ -f "$file" ]] && [[ $(stat -c%s "$file" 2>/dev/null || echo 0) -gt 102400 ]]
            }

            # Search in the target/release directory
            echo "Searching in $MAIN_TARGET_DIR/release..."
            while IFS= read -r -d '' file; do
              if is_binary "$file"; then
                BINARY_NAME="$file"
                echo "Found binary: $BINARY_NAME"
                break
              fi
            done < <(find "$MAIN_TARGET_DIR/release" -name "cosmic*" -type f -executable ! -name "*.ftl" ! -name "*.json" ! -name "*.xml" ! -name "*.toml" -print0 2>/dev/null)

            # Validate we found a binary
            if [[ -z "$BINARY_NAME" || ! -f "$BINARY_NAME" ]]; then
            echo "::error:: No cosmic binary found after build"
            echo "::error:: All cosmic files found:"
            find "$MAIN_TARGET_DIR/release" -name "cosmic*" -type f | head -10
            echo "::error:: Target directory contents:"
            ls -la "$MAIN_TARGET_DIR/release/" 2>/dev/null || echo "Cannot list $MAIN_TARGET_DIR/release"
            echo "::error:: All executable files in $MAIN_TARGET_DIR/release:"
            find "$MAIN_TARGET_DIR/release" -type f -executable 2>/dev/null | head -10
            echo "::error:: File sizes in $MAIN_TARGET_DIR/release:"
            find "$MAIN_TARGET_DIR/release" -type f -exec ls -lh {} \; 2>/dev/null | head -10
            exit 1
            fi

           echo "Final binary: $BINARY_NAME"
           chmod +x "$BINARY_NAME"
           if [[ -n "$BINARY_NAME" && -f "$BINARY_NAME" ]]; then
           BINARY_BASENAME=$(basename "$BINARY_NAME")
           cp "$BINARY_NAME" "$APPLET_ARTIFACT_DIR/$BINARY_BASENAME"
           echo "Copied $BINARY_BASENAME to artifacts"
           else
           echo "::error:: No binary found in $MAIN_TARGET_DIR/release"
           exit 1
           fi

           # Copy justfile if it exists
           if [[ -f "justfile" ]]; then
             cp justfile "$APPLET_ARTIFACT_DIR/"
             echo "Copied justfile to artifacts"
           fi

           # Parse entire justfile to identify all file references (excluding build commands)
           if [[ -f "justfile" ]]; then
             echo "Parsing justfile for all file references..."

             # Read the entire justfile content
             JUSTFILE_CONTENT=$(cat justfile)

             # Function to copy file/directory preserving structure
             copy_with_structure() {
               local src="$1"
               local dst_base="$2"

               # Skip empty strings, system paths, and non-existent paths
               if [[ -z "$src" || "$src" =~ ^/usr || "$src" =~ ^/etc || "$src" =~ ^/var || ! -e "$src" ]]; then
                 return 0
               fi

               local dst_path="$dst_base/$src"
               mkdir -p "$(dirname "$dst_path")"
               if [[ -d "$src" ]]; then
                 cp -r "$src" "$dst_path"
                 echo "Copied directory $src to artifacts (preserving structure)"
               else
                 cp "$src" "$dst_path"
                 echo "Copied file $src to artifacts (preserving structure)"
               fi
             }

              # Extract variable assignments that might contain paths
              echo "$JUSTFILE_CONTENT" | grep -E "^[a-zA-Z][a-zA-Z0-9_-]*\s*:=.*" | while IFS= read -r line; do
                # Extract paths from variable assignments
                # Pattern: desktop-src := 'res' / desktop
                echo "$line" | grep -oE "'[^']*'|\"[^\"]*\"" | sed "s/['\"]//g" | while read -r path_part; do
                  # Skip empty strings, single quotes, and system paths
                  if [[ -n "$path_part" && "$path_part" != "'" && "$path_part" != "\"" && ! "$path_part" =~ ^/usr && ! "$path_part" =~ ^/etc && ! "$path_part" =~ ^/var ]]; then
                    copy_with_structure "$path_part" "$APPLET_ARTIFACT_DIR"
                  fi
                done
              done

             # Skip build-related targets and parse file references from non-build targets
             echo "$JUSTFILE_CONTENT" | grep -v -E "^(build|test|check|clean|run|vendor|fmt|dev|default|spellcheck|validate|flatpak)[^:]*:" | while IFS= read -r line; do
               # Skip empty lines and comments
               [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

                # Pattern 1: Variable references in install commands ({{bin-src}}, {{desktop-src}}, etc.)
                echo "$line" | grep -oE '\{\{[^}]+\}\}' | sed 's/[{}]*//g' | while read -r var_name; do
                  # Skip empty variable names
                  [[ -z "$var_name" ]] && continue
                  # Look for the variable definition in the justfile
                  var_value=$(echo "$JUSTFILE_CONTENT" | grep -E "^[[:space:]]*$var_name\s*:=" | tail -1 | sed -E "s/^[[:space:]]*$var_name\s*:=\s*//" | sed "s/[[:space:]]*$//")
                  if [[ -n "$var_value" ]]; then
                    # Resolve the variable value (handle concatenations like 'res' / desktop)
                    resolved_path=$(echo "$var_value" | sed "s/'//g" | sed "s| |/|g" | sed "s|/ |//g")
                    # Skip empty resolved paths
                    [[ -n "$resolved_path" ]] && copy_with_structure "$resolved_path" "$APPLET_ARTIFACT_DIR"
                  fi
                done

                # Pattern 2: Direct file paths in install commands
                if echo "$line" | grep -q "install.*-D"; then
                  # Extract source files from install commands (first argument after -D)
                  install_src=$(echo "$line" | sed -E 's/.*install[^-]*-D[^[:space:]]+[[:space:]]+([^[:space:]]+).*/\1/')
                  # Skip if it's a variable reference (already handled above) or empty
                  if [[ -n "$install_src" && ! "$install_src" =~ ^\{\{ ]]; then
                    clean_src=$(echo "$install_src" | sed "s/[{}']//g")
                    [[ -n "$clean_src" ]] && copy_with_structure "$clean_src" "$APPLET_ARTIFACT_DIR"
                  fi
                fi

                # Pattern 3: for loops with directory paths
                if echo "$line" | grep -q "for.*in.*ls"; then
                  # Extract directory from for loops like "for size in `ls {{icons-src}}`"
                  loop_dir=$(echo "$line" | sed 's/`ls //' | sed 's/`//' | sed 's/[{}]*//g')
                  [[ -n "$loop_dir" ]] && copy_with_structure "$loop_dir" "$APPLET_ARTIFACT_DIR"
                fi

                # Pattern 4: Import statements
                if echo "$line" | grep -q "import"; then
                  import_file=$(echo "$line" | grep -oE 'import "[^"]+"' | sed 's/import "//' | sed 's/"//')
                  [[ -n "$import_file" ]] && copy_with_structure "$import_file" "$APPLET_ARTIFACT_DIR"
                fi
             done

             # Pattern 5: Common directories that appear in all applets
             for dir in res data i18n-json schema icons; do
               copy_with_structure "$dir" "$APPLET_ARTIFACT_DIR"
             done

              # Pattern 6: Copy any .desktop, .metainfo.xml, .svg files found anywhere (preserving structure)
              while IFS= read -r -d '' file; do
                copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
              done < <(find . -name "*.desktop" -type f 2>/dev/null)
              while IFS= read -r -d '' file; do
                copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
              done < <(find . -name "*.metainfo.xml" -type f 2>/dev/null)
              while IFS= read -r -d '' file; do
                copy_with_structure "${file#./}" "$APPLET_ARTIFACT_DIR"
              done < <(find . -name "*.svg" -type f 2>/dev/null)

             # Pattern 7: Check for install.sh scripts (like in privacy-indicator)
             if [[ -f "install.sh" ]]; then
               copy_with_structure "install.sh" "$APPLET_ARTIFACT_DIR"
             fi

           else
             # Fallback: copy common directories if no justfile
             echo "No justfile found, using fallback directory detection"
             for dir in res data i18n-json schema icons; do
               if [[ -d "$dir" ]]; then
                 cp -r "$dir" "$APPLET_ARTIFACT_DIR/"
                 echo "Copied $dir directory to artifacts (fallback)"
               fi
             done
           fi

            popd >/dev/null
          ) || {
            echo "::error:: Build timed out or failed for ${APPLET_NAME}"
            exit 1
          }

          echo "::endgroup::"

      - name: Upload Applet Artifact
        run: |
          APPLET_NAME="${{ github.event.client_payload.applet_name }}"
          if [ -d "/tmp/artifacts/${APPLET_NAME}" ]; then
            gh run upload --name "${APPLET_NAME}" "/tmp/artifacts/${APPLET_NAME}"
          fi
